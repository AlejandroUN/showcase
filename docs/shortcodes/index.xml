<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Visual Computing</title><link>https://AlejandroUN.github.io/docs/shortcodes/</link><description>Recent content on Visual Computing</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://AlejandroUN.github.io/docs/shortcodes/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://AlejandroUN.github.io/docs/shortcodes/log/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://AlejandroUN.github.io/docs/shortcodes/log/</guid><description>Logs # March 29th Platonic solid Textured
TextureMode(Normal)
Ishihara Test
Change Image Colors Palette from a diagnostic
May 5th Rendering - Rasterization
Antialiasing implementation for a triangle using barycentric coordinates.
Scene Trees - Main Spaces
Implementation of a 3D brush using the ml5.js library.</description></item><item><title/><link>https://AlejandroUN.github.io/docs/shortcodes/Workshop1/blindness/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://AlejandroUN.github.io/docs/shortcodes/Workshop1/blindness/</guid><description>Color blindness # Problem statement # People with colour vision deficiency find it difficult to identify and distinguish between certain colours.
Colour vision deficiency is not usually anything to be concerned about.
Most people get used to it over time, it will not normally get any worse, and it&amp;rsquo;s rarely a sign of anything serious.
But it can sometimes cause issues such as:
Difficulty at school if colours are used to help with learning Problems with food, such as identifying whether meat is fully cooked or whether fruit is ripe Getting medications confused if they&amp;rsquo;re not clearly labelled Trouble identifying safety warnings or signs Slightly limited career choices – certain jobs, such as pilots, train drivers, electricians and air traffic controllers, may require accurate colour recognition Background # Definition # Color blindness is a reduced ability to distinguish between color when compared to the standard for normal human color vision.</description></item><item><title/><link>https://AlejandroUN.github.io/docs/shortcodes/Workshop1/solids/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://AlejandroUN.github.io/docs/shortcodes/Workshop1/solids/</guid><description> Platonic Solids # A platonic solid is a polyhedron all of whose faces are congruent regular polygons, and where the same number of faces meet at every vertex. More
Tetrahedron #</description></item><item><title/><link>https://AlejandroUN.github.io/docs/shortcodes/Workshop2/mainSpaces/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://AlejandroUN.github.io/docs/shortcodes/Workshop2/mainSpaces/</guid><description>Main Spaces 3D Brush Based using a Camera # Introduction # A 3d brush was implemented using the concepts of scene trees using the p5.treegl library and the handPose ml5 library.
Background # Scene trees # Scene trees are a concept used for the spatial and graphical representation of a scene using matrices and a graph representation, more specifically that of a tree as the graph has no cycles.</description></item><item><title/><link>https://AlejandroUN.github.io/docs/shortcodes/Workshop2/Rasterization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://AlejandroUN.github.io/docs/shortcodes/Workshop2/Rasterization/</guid><description>Rasterization # Problem statement # What we do with the rasterization process is breaking down a continuous surface (the triangle) into discrete elements (the pixels). The problem is similar to trying to represent a continuous curve or surface with Lego bricks. And the solution to this problem in rendering is called anti-aliasing, that will be implemented using the barycentric coordinates.
Background # Concepts # Rasterization # Rasterization is the task of taking an image described in a vector graphics format (shapes) and converting it into a raster image (a series of pixels, dots or lines, which, when displayed together, create the image which was represented via shapes).</description></item><item><title/><link>https://AlejandroUN.github.io/docs/shortcodes/Workshop3/color-blindness-shaders/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://AlejandroUN.github.io/docs/shortcodes/Workshop3/color-blindness-shaders/</guid><description>Color Blindness Corrector Using Shaders # Problem statement # People with colour vision deficiency find it difficult to identify and distinguish between certain colours.
Colour vision deficiency is not usually anything to be concerned about.
Most people get used to it over time, it will not normally get any worse, and it&amp;rsquo;s rarely a sign of anything serious.
But it can sometimes cause issues such as:
Difficulty at school if colours are used to help with learning Problems with food, such as identifying whether meat is fully cooked or whether fruit is ripe Getting medications confused if they&amp;rsquo;re not clearly labelled Trouble identifying safety warnings or signs Slightly limited career choices – certain jobs, such as pilots, train drivers, electricians and air traffic controllers, may require accurate colour recognition Background # Shaders # Shaders can be used to define the colors of a pixel of an image in parallel.</description></item><item><title/><link>https://AlejandroUN.github.io/docs/shortcodes/Workshop3/color-brightness/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://AlejandroUN.github.io/docs/shortcodes/Workshop3/color-brightness/</guid><description>Color brightness tools # Fragment shader precision mediump float; uniform int grey_scale; uniform sampler2D texture; // interpolated texcoord (same name and type as in vertex shader) varying vec2 texcoords2; float luma(vec3 texel) { return 0.299 * texel.r + 0.587 * texel.g + 0.114 * texel.b; } float hsl(vec3 texel) { return ( max(max(texel.r,texel.g), texel.b) + min(min(texel.r,texel.g), texel.b)) / 2.0; } float hsv(vec3 texel) { return max(max(texel.r,texel.g), texel.b); } float average(vec3 texel) { return (texel.</description></item><item><title/><link>https://AlejandroUN.github.io/docs/shortcodes/Workshop3/image-processing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://AlejandroUN.github.io/docs/shortcodes/Workshop3/image-processing/</guid><description>Image processing # Introduction # Filtering is a technique for modifying or enhancing an image. For example, you can filter an image to emphasize certain features or remove other features. Image processing operations implemented with filtering include smoothing, sharpening, and edge enhancement. [1]
The value of any given pixel in the output image is determined by applying some algorithm to the values of the pixels in the neighborhood of the corresponding input pixel.</description></item><item><title/><link>https://AlejandroUN.github.io/docs/shortcodes/Workshop3/procedural-texturing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://AlejandroUN.github.io/docs/shortcodes/Workshop3/procedural-texturing/</guid><description>Procedural Texturing # bricks.frag // Author @patriciogv ( patriciogonzalezvivo.com ) - 2015 #ifdef GL_ES precision mediump float; #endif uniform vec2 u_resolution; uniform float u_time; vec2 brickTile(vec2 _st, float _zoom){ _st *= _zoom; // Here is where the offset is happening _st.x += step(1., mod(_st.y,2.0)) * 0.5; return fract(_st); } float box(vec2 _st, vec2 _size){ _size = vec2(0.5)-_size*0.5; vec2 uv = smoothstep(_size,_size+vec2(1e-4),_st); uv *= smoothstep(_size,_size+vec2(1e-4),vec2(1.0)-_st); return uv.x*uv.y; } void main(void){ vec2 st = gl_FragCoord.</description></item><item><title/><link>https://AlejandroUN.github.io/docs/shortcodes/Workshop3/uv-visualization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://AlejandroUN.github.io/docs/shortcodes/Workshop3/uv-visualization/</guid><description> UV Visualization #</description></item></channel></rss>